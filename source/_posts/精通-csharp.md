title: 精通c#（中文第六版）
date: 2015-06-11 14:42:45
categories:
  - csharp
---

![](http://img3.douban.com/lpic/s26806151.jpg)

格式：PDF
类型：扫描版
大小：26.6M

<!--more-->

## 出版信息 ##

作者: [美] Andrew Troelsen 
出版社: 人民邮电出版社
原作名: Pro C# 5.0 and the .NET 4.5 framework,sixth edition
译者: 姚琪琳 / 朱晔 / 肖逵 / 张大磊 / 王少葵 / 范睿 
出版年: 2013-7
页数: 1228
定价: 159.00元
装帧: 平装
ISBN: 9787115321817

## 简介 ##

本书是C# 领域久负盛名的经典著作，深入全面地讲解了C# 编程语言和.NET 平台的核心内容，并结合大量示例剖析相关概念。全书分为八部分：C# 和.NET 平台、C# 核心编程结构、C# 面向对象编程、高级C# 编程结构、用.NET 程序集编程、.NET 基础类库、WPF 和ASP.NET Web Forms。第6 版是对第5 版的进一步更新和完善，内容涵盖了最先进的.NET 编程技术和技巧，并准确呈现出C# 编程语言的最新变化和.NET 4.5 Framework 的新特性。
本书由微软C# MVP Andrew Troelsen 编写，第6 版专门针对C# 5.0 和.NET 4.5 进行了细致入微的修订，是各层次.NET 开发人员的必读之作。

## 目录 ##

第一部分　C#与.NET平台
第1章　.NET之道	2
1.1 　初识.NET平台　　2
1.2 　.NET平台构造块（CLR、CTS和CLS）简介　　3
1.2.1 　基础类库的作用　　3
1.2.2 　C#的优点　　4
1.2.3 　托管代码与非托管代码　　5
1.3 　其他支持.NET的编程语言　　5
1.4 　.NET程序集概览　　7
1.4.1 　CIL的作用　　8
1.4.2 　.NET类型元数据的作用　　10
1.4.3 　程序集清单的作用　　11
1.5 　CTS　　12
1.5.1 　CTS类类型　　12
1.5.2 　CTS接口类型　　12
1.5.3 　CTS结构类型　　13
1.5.4 　CTS枚举类型　　13
1.5.5 　CTS委托类型　　13
1.5.6 　CTS类型成员　　14
1.5.7 　内建的CTS数据类型　　14
1.6 　CLS　　15
1.7 　CLR　　16
1.8 　程序集/命名空间/类型的区别　　17
1.8.1 　Microsoft根命名空间的作用　　20
1.8.2 　以编程方式访问命名空间　　20
1.8.3 　引用外部程序集　　21
1.9 　使用ildasm.exe探索程序集　　22
1.9.1 　查看CIL代码　　23
1.9.2 　查看类型元数据　　23
1.9.3 　查看程序集元数据（即清单）　　24
1.10 　.NET的平台无关性　　24
1.11 　Windows 8应用程序简介　　25
1.11.1 　构建Windows 8应用程序　　26
1.11.2 　.NET在Windows 8中的作用　　27
1.12 　小结　　28
第2章　构建C#应用程序　　29
2.1 　.NET Framework 4.5 SDK的作用　　29
2.2 　用csc.exe构建C#应用程序　　30
2.2.1 　指定输入输出目标　　31
2.2.2 　引用外部程序集　　32
2.2.3 　引用多个外部程序集　　33
2.2.4 　编译多个源文件　　33
2.2.5 　使用C#响应文件　　34
2.3 　使用Notepad++构建.NET应用程序　　35
2.4 　使用SharpDevelop构建.NET应用程序　　36
2.5 　使用Visual C# Express构建.NET应用程序　　38
2.6 　使用Visual Studio构建.NET应用程序　　39
2.6.1 　Visual Studio的独特功能　　39
2.6.2 　使用New Project对话框指向.NET Framework　　40
2.6.3 　解决方案资源管理器　　40
2.6.4 　Class View工具　　42
2.6.5 　Object Browser工具　　43
2.6.6 　集成对代码重构的支持　　43
2.6.7 　代码扩展和围绕技术　　45
2.6.8 　可视化Class Designer　　47
2.6.9 　集成的.NET Framework 4.5 SDK文档系统　　50
2.7 　小结　　51
第二部分　C#核心编程结构
第3章　C#核心编程结构Ⅰ　　54
3.1 　一个简单的C#程序　　54
3.1.1 　Main()方法的其他形式　　55
3.1.2 　指定应用程序错误代码　　56
3.1.3 　处理命令行参数　　57
3.1.4 　使用Visual Studio指定命令行参数　　59
3.2 　有趣的题外话：System.Environment类的其他成员　　59
3.3 　System.Console类　　61
3.3.1 　使用Console类进行基本的输入和输出　　61
3.3.2 　格式化控制台输出　　62
3.3.3 　格式化数值数据　　63
3.3.4 　在控制台应用程序外格式化数值数据　　64
3.4 　系统数据类型和相应的C#关键字　　64
3.4.1 　变量声明和初始化　　65
3.4.2 　内建数据类型与new操作符　　67
3.4.3 　数据类型类的层次结构　　67
3.4.4 　数值数据类型的成员　　69
3.4.5 　System.Boolean的成员　　69
3.4.6 　System.Char的成员　　69
3.4.7 　从字符串数据中解析数值　　70
3.4.8 　System.DateTime和System.TimeSpan　　70
3.4.9 　System.Numerics.dll程序集　　71
3.5 　使用字符串数据　　72
3.5.1 　基本的字符串操作　　73
3.5.2 　字符串拼接　　73
3.5.3 　转义字符　　74
3.5.4 　定义逐字字符串　　75
3.5.5 　字符串和相等性　　75
3.5.6 　字符串是不可变的　　76
3.5.7 　System.Text.StringBuilder类型　　77
3.6 　窄化和宽化数据类型转换　　78
3.6.1 　checked关键字　　80
3.6.2 　设定项目级别的溢出检测　　81
3.6.3 　unchecked关键字　　82
3.7 　隐式类型本地变量　　82
3.7.1 　隐式类型变量的限制　　84
3.7.2 　隐式类型数据是强类型数据　　84
3.7.3 　隐式类型本地变量的用途　　85
3.8 　C#迭代结构　　86
3.8.1 　for循环　　86
3.8.2 　foreach循环　　87
3.8.3 　while和do/while循环结构　　87
3.9 　条件结构和关系/相等操作符　　88
3.9.1 　if/else语句　　88
3.9.2 　关系/相等操作符　　88
3.9.3 　逻辑操作符　　89
3.9.4 　switch语句　　89
3.10 　小结　　91
第4章　C#核心编程结构Ⅱ　　92
4.1 　方法和参数修饰符　　92
4.1.1 　默认的参数传递行为　　93
4.1.2 　out修饰符　　94
4.1.3 　ref修饰符　　95
4.1.4 　params修饰符　　96
4.1.5 　定义可选参数　　97
4.1.6 　使用命名参数调用方法　　98
4.1.7 　成员重载　　99
4.2 　C#数组　　101
4.2.1 　C#数组初始化语法　　102
4.2.2 　隐式类型本地数组　　103
4.2.3 　定义object数组　　103
4.2.4 　使用多维数组　　104
4.2.5 　数组作为参数（和返回值）　　105
4.2.6 　System.Array基类　　106
4.3 　枚举类型　　107
4.3.1 　控制枚举的底层存储　　108
4.3.2 　声明枚举变量　　109
4.3.3 　System.Enum类型　　110
4.3.4 　动态获取枚举的名称/值对　　110
4.4 　结构类型　　112
4.5 　值类型和引用类型　　115
4.5.1 　值类型、引用类型和赋值操作符　　116
4.5.2 　包含引用类型的值类型　　117
4.5.3 　按值传递引用类型　　119
4.5.4 　按引用传递引用类型　　120
4.5.5 　值类型和引用类型：最后的细节　　121
4.6 　C#可空类型　　122
4.6.1 　使用可空类型　　123
4.6.2 　??操作符　　124
4.7 　小结　　124
第三部分　C#面向对象编程
第5章　封装　　126
5.1 　C#类类型　　126
5.2 　构造函数　　129
5.2.1 　默认构造函数的作用　　129
5.2.2 　定义自定义的构造函数　　130
5.2.3 　再谈默认构造函数　　131
5.3 　this关键字的作用　　132
5.3.1 　使用this进行串联构造函数调用　　133
5.3.2 　观察构造函数流程　　135
5.3.3 　再谈可选参数　　137
5.4 　static关键字　　138
5.4.1 　定义静态数据　　138
5.4.2 　定义静态方法　　140
5.4.3 　定义静态构造函数　　141
5.4.4 　定义静态类　　143
5.5 　定义OOP的支柱　　144
5.5.1 　封装的作用　　144
5.5.2 　继承的作用　　144
5.5.3 　多态的作用　　146
5.6 　C#访问修饰符　　147
5.6.1 　默认的访问修饰符　　148
5.6.2 　访问修饰符和嵌套类型　　148
5.7 　第一个支柱：C#的封装服务　　149
5.7.1 　使用传统的访问方法和修改方法执行封装　　149
5.7.2 　使用.NET属性进行封装　　151
5.7.3 　使用类的属性　　154
5.7.4 　只读和只写属性　　155
5.7.5 　静态属性　　156
5.8 　自动属性　　156
5.8.1 　与自动属性交互　　158
5.8.2 　关于自动属性和默认值　　158
5.9 　对象初始化语法　　160
5.9.1 　使用初始化语法调用自定义构造函数　　161
5.9.2 　初始化内部类型　　162
5.10 　常量数据　　163
5.10.1 　只读字段　　164
5.10.2 　静态只读字段　　165
5.11 　分部类型　　165
5.12 　小结　　167
第6章　继承和多态　　168
6.1 　继承的基本机制　　168
6.1.1 　指定既有类的父类　　169
6.1.2 　多个基类　　170
6.1.3 　sealed关键字　　171
6.2 　回顾Visual Studio类关系图　　172
6.3 　OOP的第二个支柱：继承　　173
6.3.1 　使用base关键字控制基类的创建　　174
6.3.2 　家族的秘密：protected关键字　　176
6.3.3 　增加密封类　　177
6.4 　包含/委托编程　　178
6.5 　OOP的第三个支柱：C#的多态支持　　180
6.5.1 　virtual和override关键字　　181
6.5.2 　使用Visual Studio IDE重写虚方法　　183
6.5.3 　密封虚成员　　184
6.5.4 　抽象类　　184
6.5.5 　构建多态接口　　186
6.5.6 　成员投影　　189
6.6 　基类/派生类的转换规则　　191
6.6.1 　C#的as关键字　　192
6.6.2 　C#的is关键字　　193
6.7 　超级父类：System.Object　　193
6.7.1 　重写System.Object.ToString()　　196
6.7.2 　重写System.Object.Equals()　　196
6.7.3 　重写System.Object.GetHashCode()　　197
6.7.4 　测试修改后的Person类　　198
6.7.5 　System.Object的静态成员　　199
6.8 　小结　　199
第7章　结构化异常处理　　200
7.1 　错误、bug与异常　　200
7.2 　.NET异常处理的作用　　201
7.2.1 　.NET异常处理的四要素　　202
7.2.2 　System.Exception基类　　202
7.3 　最简单的例子　　203
7.3.1 　引发普通的异常　　205
7.3.2 　捕获异常　　206
7.4 　配置异常的状态　　207
7.4.1 　TargetSite属性　　207
7.4.2 　StackTrace属性　　208
7.4.3 　HelpLink属性　　208
7.4.4 　Data属性　　209
7.5 　系统级异常　　211
7.6 　应用程序级异常　　211
7.6.1 　构建自定义异常，第一部分　　212
7.6.2 　构建自定义异常，第二部分　　213
7.6.3 　构建自定义异常，第三部分　　214
7.7 　处理多个异常　　215
7.7.1 　通用的catch语句　　217
7.7.2 　再次引发异常　　218
7.7.3 　内部异常　　218
7.7.4 　finally块　　219
7.8 　谁在引发什么异常　　220
7.9 　未处理异常的后果　　220
7.10 　使用Visual Studio调试未处理的异常　　221
7.11 　小结　　222
第8章　接口　　223
8.1 　接口类型　　223
8.2 　定义自定义接口　　226
8.3 　实现接口　　227
8.4 　在对象级别调用接口成员　　229
8.4.1 　获取接口引用：as关键字　　230
8.4.2 　获取接口引用：is关键字　　230
8.5 　接口作为参数　　231
8.6 　接口作为返回值　　233
8.7 　接口类型数组　　233
8.8 　使用Visual Studio实现接口　　234
8.9 　显式接口实现　　235
8.10 　设计接口层次结构　　238
8.11 　构建可枚举类型（IEnumerable和IEnumerator）　　241
8.11.1 　用yield关键字构建迭代器方法　　243
8.11.2 　构建命名迭代器　　244
8.12 　构建可克隆的对象（ICloneable）　　245
8.13 　构建可比较的对象（IComparable）　　249
8.13.1 　指定多个排序顺序　　252
8.13.2 　自定义属性、自定义排序类型　　253
8.14 　小结　　253
第四部分　高级C#编程结构
第9章　集合与泛型　　256
9.1 　集合类的动机　　256
9.1.1 　System.Collections命名空间　　257
9.1.2 　System.Collections.Specialized命名空间　　259
9.2 　非泛型集合的问题　　260
9.2.1 　性能问题　　260
9.2.2 　类型安全问题　　263
9.2.3 　初识泛型集合　　265
9.3 　泛型类型参数的作用　　266
9.3.1 　为泛型类/结构指定类型参数　　267
9.3.2 　为泛型成员指定类型参数　　268
9.3.3 　为泛型接口指定类型参数　　269
9.4 　System.Collections.Generic命名空间　　270
9.4.1 　集合初始化语法　　271
9.4.2 　使用List<T>类　　272
9.4.3 　使用Stack<T>类　　273
9.4.4 　使用Queue<T>类　　274
9.4.5 　使用SortedSet<T>类　　275
9.5 　System.Collections.ObjectModel命名空间　　277
9.6 　创建自定义泛型方法　　279
9.7 　创建自定义泛型结构和类　　282
9.8 　类型参数的约束　　284
9.8.1 　使用where关键字的示例　　284
9.8.2 　操作符约束的不足　　285
9.9 　小结　　286
第10章　委托、事件和Lambda表达式　　287
10.1 　.NET委托类型　　287
10.1.1 　在C#中定义委托类型　　288
10.1.2 　System.MulticastDelegate与System.Delegate基类　　290
10.2 　最简单的委托示例　　291
10.3 　使用委托发送对象状态通知　　293
10.3.1 　支持多路广播　　296
10.3.2 　从委托的调用列表中移除成员　　297
10.3.3 　方法组转换语法　　298
10.4 　泛型委托　　300
10.5 　C#事件　　303
10.5.1 　event关键字　　304
10.5.2 　揭开事件的神秘面纱　　305
10.5.3 　监听传入的事件　　306
10.5.4 　使用Visual Studio简化事件注册　　307
10.5.5 　创建自定义的事件参数　　308
10.5.6 　泛型EventHandler<T>委托　　309
10.6 　C#匿名方法　　310
10.7 　Lambda表达式　　313
10.7.1 　剖析Lambda表达式　　315
10.7.2 　使用多个语句处理参数　　316
10.7.3 　含有多个（或零个）参数的Lambda表达式　　317
10.7.4 　使用Lambda表达式重新编写CarEvents示例　　318
10.8 　小结　　319
第11章　高级C#语言特性　　320
11.1 　索引器方法　　320
11.1.1 　使用字符串值索引对象　　322
11.1.2 　重载索引器方法　　323
11.1.3 　多维的索引器　　323
11.1.4 　在接口类型上定义索引器　　324
11.2 　操作符重载　　325
11.2.1 　重载二元操作符　　325
11.2.2 　+=与-=操作符　　327
11.2.3 　重载一元操作符　　328
11.2.4 　重载相等操作符　　329
11.2.5 　重载比较操作符　　329
11.2.6 　操作符重载的最后思考　　330
11.3 　自定义类型转换　　331
11.3.1 　回顾：数值转换　　331
11.3.2 　回顾：相关的类类型间的转换　　331
11.3.3 　创建自定义转换例程　　332
11.3.4 　Square类型的其他显式转换　　334
11.3.5 　定义隐式转换例程　　335
11.4 　扩展方法　　336
11.4.1 　定义扩展方法　　336
11.4.2 　在实例层次上调用扩展方法　　337
11.4.3 　导入扩展方法　　338
11.4.4 　扩展方法的智能感知　　339
11.4.5 　扩展实现了指定接口的类型　　339
11.5 　匿名类型　　340
11.5.1 　定义匿名类型　　341
11.5.2 　匿名类型的内部表示方式　　342
11.5.3 　方法ToString()和GetHashCode()的实现　　343
11.5.4 　匿名类型的相等语义　　344
11.5.5 　包含匿名类型的匿名类型　　345
11.6 　指针类型　　346
11.6.1 　unsafe关键字　　347
11.6.2 　*和&操作符　　348
11.6.3 　不安全（与安全）交换功能　　349
11.6.4 　通过指针访问字段　　350
11.6.5 　stackalloc关键字　　350
11.6.6 　使用fixed关键字固定类型　　351
11.6.7 　sizeof关键字　　352
11.7 　小结　　352
第12章　LINQ to Object　　353
12.1 　LINQ特有的编程结构　　353
12.1.1 　隐式类型本地变量　　354
12.1.2 　对象和集合初始化语法　　354
12.1.3 　Lambda表达式　　355
12.1.4 　扩展方法　　355
12.1.5 　匿名类型　　356
12.2 　LINQ的作用　　356
12.2.1 　LINQ表达式是强类型的　　357
12.2.2 　核心LINQ程序集　　357
12.3 　将LINQ查询应用于原始数组　　358
12.3.1 　再一次，不使用LINQ　　359
12.3.2 　反射LINQ结果集　　360
12.3.3 　LINQ和隐式类型本地变量　　361
12.3.4 　LINQ和扩展方法　　362
12.3.5 　延迟执行的作用　　363
12.3.6 　立即执行的作用　　364
12.4 　返回LINQ查询的结果　　365
12.5 　将LINQ查询应用到集合对象　　367
12.5.1 　访问包含的子对象　　367
12.5.2 　将LINQ查询应用于非泛型集合　　368
12.5.3 　使用OfType<T>()筛选数据　　369
12.6 　C# LINQ查询操作符　　369
12.6.1 　基本的选择语法　　371
12.6.2 　获取数据子集　　371
12.6.3 　投影新数据类型　　372
12.6.4 　使用Enumerable获取总数　　373
12.6.5 　反转结果集　　373
12.6.6 　对表达式进行排序　　374
12.6.7 　维恩图工具　　374
12.6.8 　移除重复　　375
12.6.9 　LINQ聚合操作　　376
12.7 　LINQ查询语句的内部表示　　376
12.7.1 　用查询操作符建立查询表达式（复习）　　377
12.7.2 　使用Enumerable类型和Lambda表达式来建立查询表达式　　377
12.7.3 　使用Enumerable类型和匿名方法来建立查询表达式　　379
12.7.4 　用Enumerable类型和原始委托建立查询表达式　　379
12.8 　小结　　380
第13章　对象的生命周期　　381
13.1 　类、对象和引用　　381
13.2 　对象生命周期的基础　　382
13.2.1 　CIL的new指令　　383
13.2.2 　将对象引用设置为空　　384
13.3 　应用程序根的作用　　385
13.4 　对象的代　　386
13.5 　.NET 1.0 至.NET 3.5的并发垃圾回收　　387
13.6 　.NET 4.0及后续版本　　387
13.7 　System.GC类型　　388
13.8 　构建可终结对象　　391
13.8.1 　重写System.Object.Finalize()　　392
13.8.2 　终结过程的细节　　393
13.9 　构建可处置对象　　394
13.10 　构建可终结类型和可处置类型　　397
13.11 　延迟对象实例化　　400
13.12 　小结　　403
第五部分　用.NET程序集编程
第14章　.NET程序集入门　　406
14.1 　定义自定义命名空间　　406
14.1.1 　使用完全限定名解决命名冲突　　408
14.1.2 　使用别名解决命名冲突　　409
14.1.3 　创建嵌套的命名空间　　410
14.1.4 　Visual Studio 的默认命名空间　　411
14.2 　.NET程序集的作用　　412
14.2.1 　程序集促进代码重用　　412
14.2.2 　程序集确定类型边界　　412
14.2.3 　程序集是可版本化的单元　　412
14.2.4 　程序集是自描述的　　413
14.2.5 　程序集是可配置的　　413
14.3 　.NET程序集的格式　　413
14.3.1 　Windows文件首部　　413
14.3.2 　CLR文件首部　　414
14.3.3 　CIL代码、类型元数据和程序集清单　　415
14.3.4 　可选的程序集资源　　415
14.4 　构建和使用自定义类库　　416
14.4.1 　清单　　418
14.4.2 　CIL　　421
14.4.3 　类型元数据　　421
14.4.4 　构建C#客户端应用程序　　422
14.4.5 　构建Visual Basic客户端应用程序　　424
14.4.6 　实现跨语言继承　　425
14.5 　私有程序集　　425
14.5.1 　私有程序集的标识　　426
14.5.2 　探测过程　　426
14.5.3 　配置私有程序集　　427
14.5.4 　App.Config文件　　428
14.6 　共享程序集　　430
14.6.1 　全局程序集缓存　　430
14.6.2 　强名称　　431
14.6.3 　在命令行生成强名称　　432
14.6.4 　使用Visual Studio为程序集赋予强名称　　434
14.6.5 　在GAC中安装强名称的程序集　　436
14.7 　使用共享程序集　　437
14.8 　配置共享程序集　　439
14.8.1 　冻结当前的共享程序集　　439
14.8.2 　构建共享程序集2.0.0.0版本　　440
14.8.3 　动态重定向到共享程序集的特定版本　　441
14.9 　发行者策略程序集　　443
14.10 　<codeBase>元素　　444
14.11 　System.Configuration命名空间　　446
14.12 　配置文件架构文档　　447
14.13 　小结　　448
第15章　类型反射、晚期绑定和基于特性的编程　　449
15.1 　类型元数据的必要性　　449
15.1.1 　查看（部分）EngineState枚举的元数据　　450
15.1.2 　查看（部分）Car类型的元数据　　451
15.1.3 　研究TypeRef　　452
15.1.4 　记录定义的程序集　　452
15.1.5 　记录引用的程序集　　453
15.1.6 　记录字符串字面量　　453
15.2 　反射　　454
15.2.1 　System.Type类　　454
15.2.2 　使用System.Object.GetType()得到Type引用　　455
15.2.3 　使用typeof()得到Type引用　　455
15.2.4 　使用System.Type.GetType()得到Type引用　　455
15.3 　构建自定义的元数据查看器　　456
15.3.1 　反射方法　　456
15.3.2 　反射字段和属性　　457
15.3.3 　反射实现的接口　　457
15.3.4 　显示其他信息　　458
15.3.5 　实现Main()　　458
15.3.6 　反射泛型类型　　460
15.3.7 　反射方法参数和返回值　　460
15.4 　动态加载程序集　　461
15.5 　反射共享程序集　　464
15.6 　晚期绑定　　465
15.6.1 　System.Activator类　　466
15.6.2 　调用没有参数的方法　　467
15.6.3 　调用有参数的方法　　468
15.7 　.NET特性的作用　　469
15.7.1 　特性的使用者　　470
15.7.2 　在C#中使用特性　　470
15.7.3 　C#特性简化符号　　471
15.7.4 　为特性指定构造参数　　472
15.7.5 　Obsolete特性　　472
15.8 　构建自定义特性　　473
15.8.1 　应用自定义特性　　473
15.8.2 　命名属性语法　　474
15.8.3 　限制特性使用　　474
15.9 　程序集级别特性　　475
15.10 　使用早期绑定反射特性　　477
15.11 　使用晚期绑定反射特性　　478
15.12 　反射、晚期绑定和自定义特性的使用背景　　479
15.13 　构建可扩展的应用程序　　480
15.13.1 　构建CommonSnappable-Types.dll　　480
15.13.2 　构建C#插件　　481
15.13.3 　构建Visual Basic插件　　482
15.13.4 　构建可扩展的Windows Forms应用程序　　482
15.14 　小结　　485
第16章　动态类型和动态语言运行时　　486
16.1 　dynamic关键字的作用　　486
16.1.1 　调用动态声明的数据的成员　　488
16.1.2 　Microsoft.CSharp.dll程序集的作用　　489
16.1.3 　dynamic关键字的作用域　　490
16.1.4 　dynamic关键字的限制　　491
16.1.5 　dynamic关键字的实际用途　　491
16.2 　DLR的作用　　492
16.2.1 　表达式树的作用　　492
16.2.2 　System.Dynamic命名空间的作用　　493
16.2.3 　表达式树的动态运行时查找　　493
16.3 　使用动态类型简化后期绑定调用　　494
16.4 　使用动态数据简化COM互操作　　497
16.4.1 　主互操作程序集的作用　　498
16.4.2 　嵌入互操作元数据　　499
16.4.3 　普通COM互操作的难点　　500
16.5 　使用C# 动态数据进行COM互操作　　500
16.6 　不使用C# 动态数据进行COM互操作　　504
16.7 　小结　　505
第17章　进程、应用程序域和对象上下文　　506
17.1 　Windows进程的作用　　506
17.2 　.NET平台下与进程进行交互　　508
17.2.1 　列举运行中的进程　　510
17.2.2 　特定的进程　　511
17.2.3 　进程的线程集合　　511
17.2.4 　进程中的模块集合　　513
17.2.5 　以编程方式启动或结束进程　　514
17.2.6 　使用ProcessStartInfo类控制进程的启动　　515
17.3 　.NET应用程序域　　516
17.4 　与默认应用程序域进行交互　　518
17.4.1 　枚举加载的程序集　　519
17.4.2 　接收程序集加载通知　　520
17.5 　创建新的应用程序域　　521
17.5.1 　在自定义应用程序域中加载程序集　　522
17.5.2 　以编程方式卸载应用程序域　　523
17.6 　对象上下文边界　　525
17.6.1 　上下文灵活和上下文绑定类型　　525
17.6.2 　定义上下文绑定对象　　526
17.6.3 　研究对象的上下文　　526
17.7 　进程、应用程序域和上下文小结　　528
17.8 　小结　　528
第18章　CIL和动态程序集的作用　　529
18.1 　学习CIL语法的原因　　529
18.2 　CIL指令、特性和操作码　　530
18.2.1 　CIL指令的作用　　530
18.2.2 　CIL特性的作用　　530
18.2.3 　CIL操作码的作用　　531
18.2.4 　区别CIL操作码和CIL助记符　　531
18.3 　入栈和出栈：CIL基于栈的本质　　532
18.4 　正反向工程　　533
18.4.1 　CIL代码标签的作用　　536
18.4.2 　与CIL交互：修改*.il文件　　536
18.4.3 　使用ilasm.exe编译CIL代码　　537
18.4.4 　peverify.exe的作用　　538
18.5 　CIL指令和特性　　539
18.5.1 　在CIL中指定外部引用程序集　　539
18.5.2 　在CIL中定义当前程序集　　539
18.5.3 　在CIL中定义命名空间　　540
18.5.4 　在CIL中定义类类型　　540
18.5.5 　在CIL中定义和实现接口　　541
18.5.6 　在CIL中定义结构　　542
18.5.7 　在CIL中定义枚举　　542
18.5.8 　在CIL中定义泛型　　543
18.5.9 　编译CILTypes.il文件　　543
18.6 　.NET基础类库、C#和CIL数据类型的映射　　544
18.7 　在CIL中定义类型成员　　544
18.7.1 　在CIL中定义数据字段　　545
18.7.2 　在CIL中定义类型的构造函数　　545
18.7.3 　在CIL中定义属性　　546
18.7.4 　定义成员参数　　546
18.8 　剖析CIL操作码　　547
18.8.1 　.maxstack指令　　548
18.8.2 　在CIL中声明本地变量　　549
18.8.3 　在CIL中映射参数到本地变量　　550
18.8.4 　this隐式引用　　550
18.8.5 　在CIL中使用循环结构　　551
18.9 　使用CIL构建.NET程序集　　551
18.9.1 　构建CILCars.dll　　551
18.9.2 　构建CILCarClient.exe　　554
18.10 　动态程序集　　555
18.10.1 　System.Reflection.Emit命名空间　　556
18.10.2 　System.Reflection.Emit.ILGenerator的作用　　557
18.10.3 　产生动态的程序集　　557
18.10.4 　产生程序集和模块集　　559
18.10.5 　ModuleBuilder类型的作用　　560
18.10.6 　产生HelloClass类型和字符串成员变量　　561
18.10.7 　产生构造函数　　561
18.10.8 　产生SayHello()方法　　562
18.10.9 　使用动态产生的程序集　　563
18.11 　小结　　564
第六部分　.NET基础类库
第19章　多线程、并行和异步编程　　566
19.1 　进程、应用程序域、上下文及线程之间的关系　　566
19.1.1 　并发问题　　567
19.1.2 　线程同步的作用　　568
19.2 　.NET委托的简短回顾　　568
19.3 　委托的异步性　　570
19.3.1 　BeginInvoke()和EndInvoke()方法　　570
19.3.2 　System.IAsyncResult接口　　570
19.4 　异步调用方法　　571
19.4.1 　同步调用线程　　572
19.4.2 　AsyncCallback委托的作用　　573
19.4.3 　AsyncResult类的作用　　575
19.4.4 　传递和接收自定义状态数据　　575
19.5 　System.Threading命名空间　　576
19.6 　System.Threading.Thread类　　577
19.6.1 　获得当前执行线程的统计信息　　578
19.6.2 　Name属性　　579
19.6.3 　Priority属性　　579
19.7 　手工创建次线程　　580
19.7.1 　使用ThreadStart委托　　580
19.7.2 　使用ParameterizedThreadStart委托　　582
19.7.3 　AutoResetEvent类　　583
19.7.4 　前台线程和后台线程　　584
19.8 　并发问题　　585
19.8.1 　使用C#的lock关键字进行同步　　588
19.8.2 　使用System.Threading.Monitor类型进行同步　　589
19.8.3 　使用System.Threading.Interlocked类型进行同步　　590
19.8.4 　使用[Synchronization]特性进行同步　　591
19.9 　使用TimerCallback编程　　592
19.10 　CLR线程池　　593
19.11 　使用任务并行库进行并行编程　　595
19.11.1 　任务并行库API　　595
19.11.2 　Parallel类的作用　　596
19.11.3 　使用Parallel类的数据并行　　596
19.11.4 　在次线程中访问UI元素　　598
19.11.5 　Task类　　599
19.11.6 　处理取消请求　　599
19.11.7 　使用并行类的任务并行　　601
19.12 　并行LINQ查询（PLINQ）　　603
19.12.1 　使用PLINQ查询　　604
19.12.2 　取消PLINQ查询　　604
19.13 　.NET 4.5下的异步调用　　605
19.13.1 　C# async和await关键字初探　　606
19.13.2 　异步方法的命名约定　　607
19.13.3 　返回void的异步方法　　609
19.13.4 　具有多个await的异步方法　　609
19.13.5 　用async/await改进AddWithThreads示例　　610
19.14 　小结　　611
第20章　文件输入输出和对象序列化　　612
20.1 　研究System.IO命名空间　　612
20.2 　Directory(Info)和File(Info)类型　　613
20.3 　使用DirectoryInfo类型　　614
20.3.1 　使用DirectoryInfo类型枚举出文件　　616
20.3.2 　使用DirectoryInfo类型创建子目录　　616
20.4 　使用Directory类型　　617
20.5 　使用DriveInfo类类型　　618
20.6 　使用FileInfo类　　619
20.6.1 　FileInfo.Create()方法　　620
20.6.2 　FileInfo.Open()方法　　621
20.6.3 　FileInfo.OpenRead()和FileInfo.OpenWrite()方法　　622
20.6.4 　FileInfo.OpenText()方法　　622
20.6.5 　FileInfo.CreateText()和FileInfo.AppendText()方法　　623
20.7 　使用File类型　　623
20.8 　Stream抽象类　　625
20.9 　使用StreamWriter和StreamReader类型　　627
20.9.1 　写文本文件　　628
20.9.2 　读文本文件　　628
20.9.3 　直接创建StreamWriter/StreamReader类型　　629
20.10 　使用StringWriter和StringReader类型　　630
20.11 　使用BinaryWriter和BinaryReader　　631
20.12 　以编程方式“观察”文件　　632
20.13 　对象序列化　　634
20.14 　为序列化配置对象　　637
20.14.1 　定义可序列化的类型　　637
20.14.2 　公共字段、私有字段和公共属性　　638
20.15 　选择序列化格式化程序　　638
20.15.1 　IFormatter和IRemoting-Formatting接口　　639
20.15.2 　在格式化程序中的类型保真　　640
20.16 　使用BinaryFormatter序列化对象　　641
20.17 　使用SoapFormatter序列化对象　　642
20.18 　使用XmlSerializer序列化对象　　643
20.19 　序列化对象集合　　645
20.20 　自定义Soap/Binary序列化过程　　647
20.20.1 　深入了解对象序列化　　647
20.20.2 　使用ISerializable自定义序列化　　648
20.20.3 　使用特性定制序列化　　650
20.21 　小结　　651
第21章　ADO.NET之一：连接层　　653
21.1 　ADO.NET的宏观定义　　653
21.2 　ADO.NET数据提供程序　　655
21.2.1 　微软提供的ADO.NET数据提供程序　　656
21.2.2 　关于System.Data.Oracle-Client.dll　　657
21.2.3 　选择第三方的数据提供程序　　657
21.3 　其他的ADO.NET命名空间　　658
21.4 　System.Data命名空间的类型　　658
21.4.1 　IDbConnection接口的作用　　659
21.4.2 　IDbTransaction接口的作用　　659
21.4.3 　IDbCommand接口的作用　　660
21.4.4 　IDbDataParameter和IDataParameter接口的作用　　660
21.4.5 　IDbDataAdapter和IDataAdapter接口的作用　　661
21.4.6 　IDataReader和IDataRecord接口的作用　　661
21.5 　使用接口的抽象数据提供程序　　662
21.6 　创建AutoLot数据库　　665
21.6.1 　创建Inventory表　　665
21.6.2 　为Inventory表添加测试记录　　667
21.6.3 　编写GetPetName()存储过程　　668
21.6.4 　创建Customers和Orders表　　669
21.6.5 　可视化创建表关系　　671
21.7 　ADO.NET数据提供程序工厂模型　　672
21.7.1 　完整的数据提供程序工厂的例子　　673
21.7.2 　数据提供程序工厂模型的潜在缺陷　　675
21.7.3 　<connectionStrings>元素　　676
21.8 　ADO.NET的连接层　　677
21.8.1 　使用连接对象　　678
21.8.2 　使用ConnectionStringBuilder对象　　679
21.8.3 　使用命令对象　　680
21.9 　使用数据读取器　　681
21.10 　构建可重用的数据访问库　　683
21.10.1 　增加连接逻辑　　684
21.10.2 　增加插入逻辑　　685
21.10.3 　增加删除逻辑　　686
21.10.4 　增加更新逻辑　　686
21.10.5 　增加选择逻辑　　687
21.10.6 　使用参数化的命令对象　　688
21.10.7 　执行存储过程　　690
21.11 　创建控制台UI前端　　691
21.11.1 　实现Main()方法　　691
21.11.2 　实现ShowInstructions()方法　　693
21.11.3 　实现ListInventory()方法　　693
21.11.4 　实现DeleteCar()方法　　694
21.11.5 　实现InsertNewCar()方法　　694
21.11.6 　实现UpdateCarPetName()方法　　695
21.11.7 　实现LookUpPetName()　　696
21.12 　数据库事务　　697
21.12.1 　ADO.NET事务对象的主要成员　　697
21.12.2 　为AutoLot数据库添加CreditRisks表　　698
21.12.3 　为InventoryDAL添加事物方法　　699
21.12.4 　测试数据库事务　　700
21.13 　小结　　701
第22章　ADO.NET之二：断开连接层　　702
22.1 　ADO.NET断开连接层　　702
22.2 　DataSet的作用　　703
22.2.1 　DataSet的主要属性　　704
22.2.2 　DataSet的主要方法　　704
22.2.3 　构建DataSet　　705
22.3 　使用DataColumn　　705
22.3.1 　构建DataColumn　　706
22.3.2 　启用自增列　　707
22.3.3 　把DataColumn对象加入DataTable　　707
22.4 　使用DataRow　　707
22.4.1 　RowState属性　　709
22.4.2 　DataRowVersion属性　　710
22.5 　使用DataTable　　710
22.5.1 　将DataTable插入到DataSet中　　711
22.5.2 　获取DataSet中的数据　　712
22.5.3 　使用DataTableReader对象处理DataTable　　713
22.5.4 　序列化DataTable/DataSet对象为XML　　714
22.5.5 　以二进制格式序列化Data-Table/DataSet对象　　715
22.6 　将DataTable对象绑定到用户界面　　716
22.6.1 　从泛型List<T>合成DataTable　　717
22.6.2 　从DataTable中删除行　　719
22.6.3 　根据筛选条件选择行　　720
22.6.4 　在DataTable中更新行　　722
22.6.5 　使用DataView类型　　723
22.7 　使用数据适配器　　724
22.7.1 　一个简单的数据适配器示例　　725
22.7.2 　映射数据库名称为友好名称　　726
22.8 　向AutoLotDAL.dll添加断开连接功能　　727
22.8.1 　定义初始类类型　　727
22.8.2 　使用SqlCommandBuilder来配置数据适配器　　728
22.8.3 　实现GetAllInventory()　　729
22.8.4 　实现UpdateInventory()　　729
22.8.5 　设置版本号　　729
22.8.6 　测试非连接的功能　　730
22.9 　多表DataSet对象和数据关系　　731
22.9.1 　建立数据适配器　　732
22.9.2 　建立表间关系　　733
22.9.3 　更新Database表　　733
22.9.4 　在关联表中切换　　734
22.10 　Windows Forms数据库设计器工具　　736
22.10.1 　可视化设计DataGridView　　736
22.10.2 　生成的App.config文件　　740
22.10.3 　强类型的DataSet　　740
22.10.4 　强类型的DataTable　　741
22.10.5 　强类型的DataRow　　742
22.10.6 　强类型的数据适配器　　743
22.10.7 　完成Windows Forms应用程序　　744
22.11 　将强类型的数据库代码隔离到类库中　　744
22.11.1 　查看生成的代码　　746
22.11.2 　用生成的代码选择数据　　747
22.11.3 　用生成的代码插入数据　　748
22.11.4 　用生成的代码删除数据　　748
22.11.5 　用生成的代码调用存储过程　　749
22.12 　LINQ to DataSet　　750
22.12.1 　DataSet Extensions库的作用　　751
22.12.2 　获取与LINQ兼容的DataTable　　752
22.12.3 　DataRowExtensions.Field-<T>()扩展方法的作用　　753
22.12.4 　从LINQ查询中生成新的DataTable　　754
22.13 　小结　　754
第23章　ADO.NET之三：Entity Framework　　756
23.1 　Entity Framework的作用　　756
23.1.1 　实体的作用　　758
23.1.2 　Entity Framework的基础知识　　760
23.2 　创建和分析EDM　　764
23.3 　对概念模型进行编程　　774
23.4 　AutoLotDAL 4.0版，加入实体　　779
23.4.1 　导航属性的作用　　780
23.4.2 　在LINQ to Entity查询中使用导航属性　　781
23.4.3 　调用存储过程　　782
23.5 　将数据实体绑定到Windows Forms GUI　　783
23.6 　展望.NET数据访问API的未来　　786
23.7 　小结　　787
第24章　LINQ to XML简介　　788
24.1 　两个XML API的故事　　788
24.1.1 　更优秀的DOM——LINQ to XML　　789
24.1.2 　更优秀的LINQ to XML——VB字面量语法　　790
24.2 　System.Xml.Linq命名空间的成员　　791
24.2.1 　LINQ to XML的轴方法　　793
24.2.2 　奇妙的XName和XNamespace　　794
24.3 　使用XElement和XDocument　　795
24.3.1 　从数组和容器中生成文档　　797
24.3.2 　加载和解析XML内容　　798
24.4 　在内存中操作XML文档　　798
24.4.1 　构建LINQ to XML应用程序的UI　　799
24.4.2 　引入Inventory.xml文件　　799
24.4.3 　定义LINQ to XML辅助类　　800
24.4.4 　将UI组装到辅助类　　801
24.5 　小结　　802
第25章　WCF　　803
25.1 　各种分布式计算API　　803
25.1.1 　DCOM的作用　　804
25.1.2 　COM+/企业服务的作用　　804
25.1.3 　MSMQ的作用　　805
25.1.4 　.NET Remoting的作用　　805
25.1.5 　XML Web服务的作用　　806
25.2 　WCF的作用　　807
25.2.1 　WCF特性概览　　807
25.2.2 　SOA概览　　808
25.2.3 　WCF概要　　809
25.3 　WCF核心程序集　　809
25.4 　Visual Studio WCF项目模板　　810
25.5 　WCF应用程序的基本构成　　811
25.6 　WCF的ABC　　812
25.6.1 　WCF契约　　813
25.6.2 　WCF绑定　　814
25.6.3 　WCF地址　　816
25.7 　构建WCF服务　　816
25.7.1 　[ServiceContract]特性　　818
25.7.2 　[OperationContract]特性　　819
25.7.3 　作为操作契约的服务类型　　819
25.8 　承载WCF服务　　820
25.8.1 　在App.config文件中创建
ABC　　820
25.8.2 　针对ServiceHost类型进行编程　　821
25.8.3 　指定库地址　　821
25.8.4 　ServiceHost类型的功能　　823
25.8.5 　<system.serviceModel>元素的细节　　824
25.8.6 　启用元数据交换　　825
25.9 　构建WCF客户端应用程序　　827
25.9.1 　使用svcutil.exe生成代理代码　　827
25.9.2 　使用Visual Studio生成代理代码　　828
25.9.3 　配置基于TCP的绑定　　830
25.10 　简化配置设置　　831
25.10.1 　使用默认终结点　　831
25.10.2 　使用多重绑定公开单独的WCF服务　　832
25.10.3 　修改WCF绑定的设置　　833
25.10.4 　使用默认的MEX行为配置　　835
25.10.5 　刷新客户端代理和选择绑定　　836
25.11 　使用WCF服务库项目模板　　837
25.11.1 　构建简单的Math服务　　837
25.11.2 　使用WcfTestClient.exe测试WCF服务　　838
25.11.3 　使用SvcConfigEditor.exe修改配置文件　　839
25.12 　以Windows服务承载WCF服务　　840
25.12.1 　在代码中指定ABC　　841
25.12.2 　启用MEX　　843
25.12.3 　创建Windows服务安装程序　　843
25.12.4 　安装Windows服务　　845
25.13 　从客户端异步调用服务　　845
25.14 　定义WCF数据契约　　847
25.14.1 　使用Web相关的WCF服务项目模板　　848
25.14.2 　实现服务契约　　849
25.14.3 　*.svc文件的作用　　851
25.14.4 　更新web.config文件　　851
25.14.5 　测试服务　　851
25.15 　小结　　852
第26章　Windows Workflow Foundation简介　　853
26.1 　定义业务流程　　853
26.2 　构建简单的工作流　　854
26.3 　Workflow运行时　　857
26.3.1 　使用WorkflowInvoker承载工作流　　857
26.3.2 　使用WorkflowApplication承载工作流　　860
26.3.3 　第一个工作流示例回顾　　861
26.4 　检查Workflow中的活动　　861
26.4.1 　控制流活动　　861
26.4.2 　流程图活动　　862
26.4.3 　消息传递活动　　862
26.4.4 　状态机活动　　863
26.4.5 　运行时活动与基元活动　　863
26.4.6 　事务活动　　863
26.4.7 　集合活动和错误处理活动　　864
26.5 　构建流程图工作流　　864
26.5.1 　在流程图中连接活动　　865
26.5.2 　使用InvokeMethod活动　　866
26.5.3 　定义工作流变量　　867
26.5.4 　使用FlowDecision活动　　868
26.5.5 　使用TerminateWorkflow活动　　868
26.5.6 　构建“true”条件　　869
26.5.7 　使用ForEach<T>活动　　870
26.5.8 　完成应用程序　　872
26.5.9 　我们做了什么　　873
26.6 　在专门的DLL中构建Squence工作流　　874
26.6.1 　定义初始化项目　　874
26.6.2 　引入程序集和命名空间　　876
26.6.3 　定义工作流参数　　877
26.6.4 　定义工作流变量　　877
26.6.5 　使用Assign活动　　878
26.6.6 　使用If和Switch活动　　879
26.6.7 　构建自定义代码活动　　882
26.7 　使用工作流库　　884
26.8 　小结　　886
第七部分　WPF
第27章　WPF和XAML　　888
27.1 　WPF背后的动机　　888
27.1.1 　统一多种不同的API　　889
27.1.2 　通过XAML将关注点分离　　889
27.1.3 　提供优化的呈现模型　　890
27.1.4 　简化复杂的UI编程　　890
27.2 　各种形式的WPF应用程序　　891
27.2.1 　传统的桌面应用程序　　891
27.2.2 　基于导航的WPF应用程序　　892
27.2.3 　XBAP应用程序　　893
27.2.4 　WPF/Silverlight关系　　894
27.3 　WPF程序集　　894
27.3.1 　Application类的作用　　896
27.3.2 　Window类的作用　　897
27.4 　创建不使用XAML的WPF应用程序　　900
27.4.1 　创建强类型的Window类　　902
27.4.2 　创建简单的用户界面　　902
27.4.3 　与应用程序级别的数据交互　　904
27.4.4 　处理Window对象的关闭　　905
27.4.5 　拦截鼠标事件　　906
27.4.6 　拦截键盘事件　　907
27.5 　仅使用XAML构建WPF应用程序　　908
27.5.1 　用XAML定义窗体对象　　909
27.5.2 　用XAML定义应用对象　　910
27.5.3 　通过msbuild.exe处理XAML文件　　911
27.6 　将标记转换为.NET程序集　　913
27.6.1 　将窗口XAML标记映射到C#代码　　913
27.6.2 　BAML的作用　　914
27.6.3 　将应用程序XAML标记映射到C#代码　　915
27.6.4 　XAML到程序集的过程摘要　　916
27.7 　WPF XAML语法　　916
27.7.1 　Kaxaml　　917
27.7.2 　XAML XML命名空间和XAML关键字　　918
27.7.3 　控制类和成员变量的可见性　　920
27.7.4 　XAML元素、XAML特性和类型转换器　　920
27.7.5 　XAML属性元素语法　　921
27.7.6 　XAML附加属性　　922
27.7.7 　XAML标记扩展　　923
27.8 　使用代码隐藏文件构建WPF应用程序　　924
27.8.1 　为MainWindow类添加代码文件　　925
27.8.2 　为MyApp类添加代码文件　　925
27.8.3 　用msbuild.exe处理代码文件　　926
27.9 　使用Visual Studio构建WPF应用程序　　927
27.9.1 　WPF项目模板　　927
27.9.2 　工具箱和XAML设计器/编辑器　　928
27.9.3 　使用Properties窗口设置属性　　929
27.9.4 　使用Properties窗口处理事件　　930
27.9.5 　在XAML编辑器中处理事件　　931
27.9.6 　Document Outline窗口　　932
27.9.7 　查看自动生成的代码文件　　933
27.10 　使用Visual Studio构建自定义XAML编辑器　　933
27.10.1 　设计窗口的GUI　　934
27.10.2 　实现Loaded事件　　935
27.10.3 　实现按钮的Click事件　　936
27.10.4 　实现Closed事件　　937
27.10.5 　测试应用程序　　937
27.10.6 　探索WPF 文档　　938
27.11 　小结　　939
第28章　使用WPF控件编程　　941
28.1 　WPF核心控件概述　　941
28.1.1 　WPF Ink控件　　942
28.1.2 　WPF Document控件　　942
28.1.3 　WPF公共对话框　　942
28.1.4 　文档中的细节　　943
28.2 　Visual Studio WPF设计器　　944
28.2.1 　在Visual Studio中使用WPF控件　　944
28.2.2 　使用Document Outline编辑器　　945
28.3 　使用面板控制内容布局　　946
28.3.1 　在Canvas面板中放置内容　　948
28.3.2 　在WrapPanel面板中放置内容　　949
28.3.3 　在StackPanel面板中放置内容　　951
28.3.4 　在Grid面板中放置内容　　952
28.3.5 　在DockPanel面板中放置内容　　954
28.3.6 　启用Panel类型的滚动功能　　955
28.3.7 　使用Visual Studio设计器配置Panel　　956
28.4 　使用嵌套面板构建窗口框架　　959
28.4.1 　构建菜单系统　　960
28.4.2 　构建工具条　　962
28.4.3 　构建状态条　　963
28.4.4 　完成UI设计　　963
28.4.5 　实现MouseEnter/MouseLeave事件处理程序　　964
28.4.6 　实现拼写检查逻辑　　964
28.5 　WPF命令　　965
28.5.1 　内置的命令对象　　965
28.5.2 　将命令连接到Command属性　　966
28.5.3 　将命令连接到任意行为　　967
28.5.4 　使用Open和Save命令　　968
28.6 　深入了解WPF API和控件　　970
28.7 　构建Ink API选项卡　　972
28.7.1 　设计工具条　　973
28.7.2 　RadioButton控件　　975
28.7.3 　处理Ink API选项卡的事件　　977
28.7.4 　InkCanvas控件　　977
28.7.5 　ComboBox控件　　980
28.7.6 　保存、加载和清除InkCanvas数据　　981
28.8 　Documents API　　982
28.8.1 　块元素和内联元素　　982
28.8.2 　文档布局管理器　　982
28.9 　构建Documents选项卡　　983
28.9.1 　使用代码填充FlowDocument　　984
28.9.2 　启用批注和便签　　985
28.9.3 　保存和加载流文档　　986
28.10 　WPF数据绑定模型　　987
28.10.1 　构建Data Binding选项卡　　988
28.10.2 　使用Visual Studio建立数据绑定　　988
28.10.3 　DataContext属性　　990
28.10.4 　使用IValueConverter进行数据转换　　991
28.10.5 　在代码中建立数据绑定　　992
28.10.6 　构建DataGrid选项卡　　992
28.11 　小结　　994
第29章　WPF图形呈现服务　　995
29.1 　理解WPF的图形呈现服务　　995
29.2 　使用形状呈现图形数据　　996
29.2.1 　在画布中添加矩形、椭圆形和线条　　998
29.2.2 　在画布中移除矩形、圆形和线条　　1001
29.2.3 　折线和多边形　　1002
29.2.4 　路径　　1002
29.3 　WPF画刷和画笔　　1005
29.3.1 　使用Visual Studio配置画刷　　1006
29.3.2 　在代码中配置画刷　　1008
29.3.3 　配置画笔　　1009
29.4 　图形变换　　1009
29.4.1 　变换概览　　1010
29.4.2 　变换Canvas数据　　1011
29.5 　使用Visual Studio变换编辑器　　1012
29.5.1 　构建初始布局　　1012
29.5.2 　在设计时应用变换　　1014
29.5.3 　在代码中变换画布　　1015
29.6 　使用绘图和几何图形呈现图形数据　　1015
29.6.1 　使用几何图形构建DrawingBrush　　1017
29.6.2 　用DrawingBrush进行绘画　　1017
29.6.3 　在DrawingImage中使用绘图类型　　1018
29.7 　Expression Design的作用　　1019
29.7.1 　将示例设计文件导出为XAML　　1019
29.7.2 　将图像数据导入WPF对象　　1021
29.7.3 　与熊共舞　　1022
29.8 　使用可视化层呈现图形数据　　1022
29.9 　小结　　1028
第30章　WPF资源、动画和样式　　1029
30.1 　理解WPF资源系统　　1029
30.2 　使用对象（逻辑）资源　　1034
30.2.1 　Resources属性的作用　　1034
30.2.2 　定义窗口级别的资源　　1035
30.2.3 　{StaticResource}标记扩展　　1037
30.2.4 　{DynamicResource}标记扩展　　1037
30.2.5 　应用程序级别的资源　　1038
30.2.6 　定义合并的资源字典　　1039
30.2.7 　定义只含资源的程序集　　1041
30.3 　理解WPF动画服务　　1042
30.3.1 　动画类型的作用　　1043
30.3.2 　To、From和By属性　　1043
30.3.3 　Timeline基类的作用　　1044
30.3.4 　用C#代码创建动画　　1044
30.3.5 　控制动画的速度　　1045
30.3.6 　动画的反转和循环　　1046
30.4 　用XAML创建动画　　1047
30.4.1 　演示图板的作用　　1047
30.4.2 　事件触发器的作用　　1048
30.4.3 　使用不连续的关键帧创建动画　　1048
30.5 　WPF样式的作用　　1049
30.5.1 　定义并使用样式　　1050
30.5.2 　重写样式设置　　1050
30.5.3 　使用TargetType自动应用样式　　1051
30.5.4 　继承已有的样式　　1052
30.5.5 　未命名样式的作用　　1052
30.5.6 　使用触发器定义样式　　1053
30.5.7 　使用多个触发器定义样式　　1053
30.5.8 　动画样式　　1054
30.5.9 　以编程方式设置样式　　1054
30.6 　小结　　1056
第31章　依赖属性、路由事件和模板　　1057
31.1 　依赖属性的作用　　1057
31.1.1 　已知的依赖属性　　1059
31.1.2 　CLR属性包装器的重要说明　　1061
31.2 　构建自定义依赖属性　　1061
31.2.1 　添加数据验证例程　　1065
31.2.2 　响应属性的改变　　1065
31.3 　路由事件　　1066
31.3.1 　路由冒泡事件的作用　　1067
31.3.2 　继续或中止冒泡　　1068
31.3.3 　路由隧道事件的作用　　1068
31.4 　逻辑树、可视树和默认模板　　1070
31.4.1 　以编程方式查看逻辑树　　1070
31.4.2 　以编程方式查看可视树　　1072
31.4.3 　以编程方式查看控件的默认模板　　1073
31.5 　使用触发器框架构建自定义控件模板　　1075
31.5.1 　模板资源　　1076
31.5.2 　使用触发器添加可视提示　　1078
31.5.3 　{TemplateBinding}标记扩展的作用　　1079
31.5.4 　ContentPresenter的作用　　1080
31.5.5 　融合模板和样式　　1081
31.6 　小结　　1082
第八部分　ASP.NET Web Form
第32章 　ASP.NET Web Form 　　1084
32.1 　HTTP的作用　　1084
32.1.1 　HTTP请求/响应循环　　1084
32.1.2 　HTTP是无状态协议　　1085
32.2 　Web应用程序和Web服务器　　1085
32.2.1 　IIS虚拟目录的作用　　1085
32.2.2 　ASP.NET Development Web Server　　1086
32.3 　HTML的作用　　1087
32.3.1 　HTML文档结构　　1087
32.3.2 　HTML表单的作用　　1088
32.3.3 　Visual Studio HTML设计器工具　　1088
32.3.4 　构建HTML表单　　1090
32.4 　客户端脚本的作用　　1091
32.5 　回发到Web服务器　　1093
32.6 　ASP.NET API概览　　1094
32.6.1 　ASP.NET 2.0及其后续版本的主要特性　　1095
32.6.2 　ASP.NET 3.5（和.NET 3.5 SP1）的主要特性　　1096
32.6.3 　ASP.NET 4.0和4.5的主要特性　　1096
32.7 　构建单个文件的ASP.NET网页　　1097
32.7.1 　引用AutoLotDAL.dll　　1098
32.7.2 　设计UI　　1098
32.7.3 　添加数据访问逻辑　　1099
32.7.4 　ASP.NET指令的作用　　1101
32.7.5 　脚本块　　1102
32.7.6 　ASP.NET控件声明　　1103
32.8 　使用代码文件构建ASP.NET Web页面　　1104
32.8.1 　引用AutoLotDAL.dll程序集　　1106
32.8.2 　更新代码文件　　1107
32.8.3 　调试并跟踪ASP.NET页面　　1107
32.9 　ASP.NET Web Site和ASP.NET Web Application　　1108
32.10 　ASP.NET网站目录结构　　1110
32.10.1 　引用程序集　　1110
32.10.2 　App_Code文件夹的作用　　1111
32.11 　页面类型的继承链　　1111
32.12 　与传入的HTTP请求交互　　1113
32.12.1 　获得浏览器统计数据　　1113
32.12.2 　访问传入的表单数据　　1114
32.12.3 　IsPostBack属性　　1115
32.13 　与输出HTTP响应交互　　1115
32.13.1 　提交HTML内容　　1116
32.13.2 　重定向用户　　1116
32.14 　ASP.NET网页的生命周期　　1117
32.14.1 　AutoEventWireUp特性的作用　　1118
32.14.2 　Error事件　　1118
32.15 　web.config文件的作用　　1120
32.16 　小结　　1121
第33章 　ASP.NET Web控件、母版页和主题　　1122
33.1 　Web控件的本质　　1122
33.1.1 　服务器端事件处理　　1123
33.1.2 　AutoPostBack属性　　1123
33.2 　Control和WebControl基类　　1124
33.2.1 　枚举所包含的控件　　1125
33.2.2 　动态添加和删除控件　　1127
33.2.3 　与动态创建的控件交互　　1128
33.2.4 　WebControl基类的功能　　1128
33.3 　ASP.NET Web控件的类别　　1129
33.3.1 　关于System.Web.UI.HtmlControls的简短说明　　1131
33.3.2 　Web控件的文档　　1132
33.4 　构建ASP.NET汽车网站　　1132
33.4.1 　使用ASP.NET母版页工作　　1133
33.4.2 　定义默认的内容页面　　1138
33.4.3 　设计Inventory内容页面　　1140
33.4.4 　设计Build-a-Car内容页面　　1143
33.5 　验证控件的作用　　1146
33.5.1 　开启客户端JavaScript验证支持　　1147
33.5.2 　RequiredFieldValidator　　1148
33.5.3 　RegularExpressionValidator　　1148
33.5.4 　RangeValidator　　1148
33.5.5 　CompareValidator　　1149
33.5.6 　创建ValidationSummary　　1150
33.5.7 　定义验证分组　　1151
33.6 　使用主题　　1152
33.6.1 　*.skin文件　　1153
33.6.2 　应用网站级别的主题　　1155
33.6.3 　在页面级别应用主题　　1155
33.6.4 　SkinID属性　　1155
33.6.5 　以编程方式分配主题　　1156
33.7 　小结　　1157
第34章　ASP.NET状态管理技术　　1158
34.1 　状态问题　　1158
34.2 　ASP.NET状态管理技术　　1160
34.3 　ASP.NET视图状态的作用　　1160
34.3.1 　演示视图状态　　1161
34.3.2 　添加自定义视图状态数据　　1162
34.4 　Global.asax文件的作用　　1163
34.4.1 　全局最后异常事件处理程序　　1164
34.4.2 　HttpApplication基类　　1165
34.5 　应用程序状态与会话状态的差别　　1165
34.5.1 　维护应用程序级的状态数据　　1166
34.5.2 　修改应用程序数据　　1168
34.5.3 　处理Web应用程序的关闭　　1169
34.6 　使用应用程序缓存　　1169
34.6.1 　使用数据缓存　　1170
34.6.2 　修改*.aspx文件　　1172
34.7 　维护会话数据　　1174
34.8 　cookie　　1177
34.8.1 　创建cookie　　1177
34.8.2 　读取传入的cookie数据　　1178
34.9 　<sessionState>元素的作用　　1179
34.9.1 　在ASP.NET会话状态服务器中保存会话数据　　1179
34.9.2 　把会话数据保存在专门的数据库中　　1180
34.10 　ASP.NET用户配置API　　1181
34.10.1 　ASPNETDB.mdf数据库　　1181
34.10.2 　在web.config中定义用户配置　　1182
34.10.3 　以编程方式访问用户配置数据　　1183
34.10.4 　分组用户配置数据并且持久化自定义对象　　1185
34.11 　小结　　1186
索引　　1187

## 下载 ##

+ [百度云下载](http://pan.baidu.com/s/1ntEgvqh)
+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YRFklgh)
+ [FilePi下载](http://filepi.com/i/6BDepp5)
+ [千易下载](http://1000eb.com/1ggha)
